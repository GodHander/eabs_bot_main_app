{"version":3,"file":"chunks/robotplayer.js","sources":["webpack://GUI/./src/playground/robotplayer.css","webpack://GUI/./src/playground/robotplayer.css?703e","webpack://GUI/./src/playground/robotplayer.jsx"],"sourcesContent":["exports = module.exports = require(\"../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".robotplayer_stage-only_pOsfU {\\r\\n    margin:0 auto;\\r\\n    width: 100%;\\r\\n    height: 100%;\\r\\n}\\r\\n\\r\\n.robotplayer_stage-only_pOsfU * {\\r\\n    -webkit-box-sizing: border-box;\\r\\n            box-sizing: border-box;\\r\\n}\\r\\n\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"stage-only\": \"robotplayer_stage-only_pOsfU\",\n\t\"stageOnly\": \"robotplayer_stage-only_pOsfU\"\n};","\nvar content = require(\"!!../../node_modules/css-loader/index.js??ref--5-1!../../node_modules/postcss-loader/src/index.js??postcss!./robotplayer.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js??ref--5-1!../../node_modules/postcss-loader/src/index.js??postcss!./robotplayer.css\", function() {\n\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js??ref--5-1!../../node_modules/postcss-loader/src/index.js??postcss!./robotplayer.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","import classNames from 'classnames';\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport {connect} from 'react-redux';\nimport {compose} from 'redux';\n\nimport Box from '../components/box/box.jsx';\nimport GUI from '../containers/gui.jsx';\nimport HashParserHOC from '../lib/hash-parser-hoc.jsx';\nimport AppStateHOC from '../lib/app-state-hoc.jsx';\nimport TitledHOC from '../lib/titled-hoc.jsx';\nimport VM from 'scratch-vm';\n\nif (process.env.NODE_ENV === 'production' && typeof window === 'object') {\n    // Warn before navigating away\n    window.onbeforeunload = () => true;\n}\n\nimport styles from './robotplayer.css';\n\n/*********************** body内开放接口定义 *********************** */\n/**\n * 调用播放器内接口 - 提供给主应用App的接口\n */\nconst callJsMethod = (funcName, paramStr, projectData) => {\n    console.log(`主应用请求调用播放器接口: ${funcName}, 参数: ${paramStr}`);\n    if (funcName === 'loadNewProjectFile') {\n        if (projectData instanceof ArrayBuffer) {\n            console.log('文件数据为ArrayBuffer类型');\n            if (projectData) {\n                window.vm.callJsMethod(funcName, paramStr, projectData);\n            } else {\n                console.log('文件数据为空！');\n            }\n        } else if (typeof projectData === 'string') {\n            console.log('文件数据为Base64加密字符串');\n            if (projectData === 'undefined' || projectData === '' || projectData === 'null') {\n                console.log('文件数据为空！');\n                return;\n            }\n            // 方式一: Blob\n            // let fileBlob = _base64ToBlob(base64Str);\n            // console.warn(fileBlob);\n            // var reader = new FileReader();\n            // reader.readAsArrayBuffer(fileBlob);\n            // reader.onload = (e) => {\n            //     console.info(reader.result); //ArrayBuffer {}\n            //     window.vm.callJsMethod('loadNewProjectFile', paramStr, reader.result);\n            // }\n            // 方式二: 直接ArrayBuffer\n            let fileArrayBuffer = _base64ToArrayBuffer(projectData);\n            console.log(`转换后的ArrayBuffer的长度: ${fileArrayBuffer.length}`);\n            window.vm.callJsMethod(funcName, paramStr, fileArrayBuffer);\n        } else {\n            console.log('文件数据为其他类型');\n            if (!projectData) {\n                console.log('文件数据为空！默认为byteArray类型');\n                return;\n            }\n            let byteArrayBlob = new Blob([projectData], {type: 'application/octet-stream'});\n            var byteArrayReader = new FileReader();\n            byteArrayReader.readAsArrayBuffer(byteArrayBlob);\n            reader.onload = () => {\n                window.vm.callJsMethod(funcName, paramStr, byteArrayReader.result);\n            }\n        }\n    } else {\n        window.vm.callJsMethod(funcName, paramStr);\n    }\n}\n\n/**\n * 向播放器发送事件 - 提供给主应用App的接口\n */\nconst appEventHandler = (evtName, evtParamStr) => {\n    window.vm.appEventHandler(evtName, evtParamStr);\n}\n       \n/**\n * Base64字符串 ---> ArrayBuffer\n */\nfunction _base64ToArrayBuffer(base64String) {\n    var byteString = window.atob(base64String); //base64 解码\n    console.warn(`base64解码后长度：${byteString.length}`);\n    \n    var arrayBuffer = new ArrayBuffer(byteString.length); //创建缓冲数组\n    var intArray = new Uint8Array(arrayBuffer); //创建视图\n    for (var i = 0; i < byteString.length; i++) {\n        intArray[i] = byteString.charCodeAt(i);\n    }\n    return intArray;\n}\n\n/**\n * Base64字符串 ---> Blob\n */\nfunction _base64ToBlob(base64String) {\n    var mimeString = 'application/octet-stream'; // mime类型\n    var byteString = window.atob(base64String); //base64 解码\n    console.warn('base64解码后长度：', byteString.length);\n    \n    var arrayBuffer = new ArrayBuffer(byteString.length); //创建缓冲数组\n    var intArray = new Uint8Array(arrayBuffer); //创建视图\n    for (var i = 0; i < byteString.length; i++) {\n        intArray[i] = byteString.charCodeAt(i);\n    }\n    return new Blob([intArray], {type: mimeString});\n}\n\n/**\n * 调用主应用App内的接口 - 提供给播放器内使用\n */\nconst callNativeMethod = (funcName, paramStr) => {\n    if (window.android) {\n        console.log(`请求调用主应用的接口: ${funcName}, 参数是 ${paramStr}`);\n        window.android.callAndroidMethod(funcName, paramStr);\n    } else {\n        console.log(`window.android为空，无法调用!`);\n    }\n}\n\n/**\n * 向主应用App内发送事件 - 提供给播放器内使用\n */\nconst dispatchPlayerEvent = (evtName, evtParamStr) => {\n    if (evtName === 'logEvent') {\n        // 该事件为测试页面用\n        let textNode = document.createTextNode(evtParamStr + '\\r\\n');\n        document.getElementById('logArea').appendChild(textNode);\n    } else {\n        if (window.android) {\n            console.log(`向主应用发送事件: ${evtName}, 参数是 ${evtParamStr}`);\n            window.android.playerEventHandler(evtName, evtParamStr);\n        } else {\n            console.log(`window.android为空，无法调用!`);\n        }\n    }\n}\n\nwindow.callJsMethod = callJsMethod;\nwindow.appEventHandler = appEventHandler;\nwindow.callNativeMethod = callNativeMethod;\nwindow.dispatchPlayerEvent = dispatchPlayerEvent;\n\nconst RobotPlayer = ({projectId, vm}) => {\n    window.vm = vm;\n    return (<Box className={classNames(styles.stageOnly)}>\n                <GUI\n                    enableCommunity\n                    projectId={projectId}\n                />\n            </Box>);\n};\n\nRobotPlayer.propTypes = {\n    projectId: PropTypes.string,\n    vm: PropTypes.instanceOf(VM).isRequired\n};\n\nconst mapStateToProps = state => ({\n    vm: state.scratchGui.vm\n});\n\nconst ConnectedPlayer = connect(\n    mapStateToProps\n)(RobotPlayer);\n\n// note that redux's 'compose' function is just being used as a general utility to make\n// the hierarchy of HOC constructor calls clearer here; it has nothing to do with redux's\n// ability to compose reducers.\nconst WrappedPlayer = compose(\n    AppStateHOC,\n    HashParserHOC,\n    TitledHOC\n)(ConnectedPlayer);\n\n\n// 挂载根节点\nconst appTarget = document.createElement('div');\ndocument.body.appendChild(appTarget);\nReactDOM.render(<WrappedPlayer isPlayerOnly={true} isFullScreen={true} robotPlayerMode={true} canSave={false}/>, appTarget);\n"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAGA;AACA;AACA;AAEA;AACA;AAAA;;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;AAGA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AAFA;AACA;AAIA;AAAA;AACA;AADA;AAAA;AACA;AAGA;AAKA;AACA;AACA;AAAA;AACA;AAOA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;A","sourceRoot":""}